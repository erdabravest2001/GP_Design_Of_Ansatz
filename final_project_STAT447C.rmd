---
title: "Estimation of Ro-Vibrational Eigenphases Using Bayesian Quantum Phase Estimation"
subtitle: "STAT 447C Final Project: Ethan Rajkumar, #55024616"
output: 
  pdf_document: 
    latex_engine: xelatex
    includes:
      in_header: tex/preamble.tex
geometry: 
  - top=5mm
  - bottom=20mm
  - left=10mm
  - right=10mm
header-includes:
  - \usepackage{amsmath, amssymb, amsthm, tcolorbox}
  - \usepackage{geometry}
  - \usepackage{algorithm}
  - \usepackage{algpseudocode}
  - \usepackage{fancyhdr}
  - \usepackage{indentfirst}
  - \usepackage{multicol}
  - \usepackage{bbm}
  - \usepackage{dsfont}
  - \usepackage{physics}
  - \usepackage{titlesec}
  - \usepackage{float}
  - \usepackage{stfloats}
  - \usepackage{chemformula}
  - \usepackage{graphicx} # Essential for including images
  - \usepackage[numbers, super]{natbib}
  - \usepackage{hyperref}
  - \usepackage{fancyhdr}
  - \usepackage{tikz}
  - \usepackage{wrapfig}
  - \usepackage{amsmath}
  - \usepackage{amssymb}
  - \usepackage{amsthm}
  - \usepackage{mdframed} % For creating the boxed environment
  - \newmdtheoremenv{definition}{Definition}
  
bibliography: tex/manuscript.bib
---
\vspace{-1.5cm}
\maketitle \begin{center}\githublogo\end{center}
\vspace{-1.5cm}
### \underline{Introduction}  {-}
\vspace{-0.3cm}
To analyze molecular characteristics, chemists often solve the following eigenvalue equation:
\begin{align}
    \mathbf{H}_{RV} \Psi(\vec{\theta}) &= E_0 \Psi(\vec{\theta})
\end{align}
In this equation, $\mathbf{H}_{RV}$ represents the Hamiltonian that accounts for the molecule's total ro-vibrational energy. The wavefunction $\Psi$, parameterized by the vector $\vec{\theta}$, serves as the eigenvector. The energy level $E_0$ corresponds to the lowest ground state energy that electrons can occupy. While simpler molecules like H$_2$ allow for straightforward single vector decompositions, larger molecules present computational challenges due to the increased size of $\mathbf{H}_{RV}$. 
Asnaashari et al.  employed a hybrid quantum-classical computing approach to address this eigenvalue problem, using a greedy induced point sampling algorithm to compute an expectation in their respective basis \cite{asnaashari2023compact}. Yanamato and Weibe attempted to use quantum phase estimation to compute the eigenphase/eigenvalues in the computational basis \cite{Yamamoto2023, Weibe2016}. However, they encountered significant scalability issues related to the time complexity of quantum circuit generation, denoted by $\mathcal{O}(\sum_k n \cdot M_k)$, where $M$ represents the time required to generate an expectation value per iteration over $n$ samples, and $k$ denotes the iteration index.
To overcome this scaling issue, this work implements a phase estimation algorithm enhanced by Bayesian Optimization to solve the eignevalue problem instead. This method was evaluated on a dichromium gas (Cr$_2$) model, using data from a discrete variable representation of the Hamiltonian. 
\vspace{-0.7cm}

###  \underline{Literature Review}  {-} 
\vspace{-0.3cm}
Taking the ro-vibrational Hamiltonian $\mathbf{H}_{RV}$ and performing the following operation to form a matrix $\mathcal{U}$ gives \(\mathcal{U} = e^{i \mathbf{H}_{RV} t} \). The expression above allows for the application of the phase estimation algorithm, which estimates the eigenvalues of the unitary operators. The algorithm then uses these eigenvalues to approximate the eigenvalues of the original Hamiltonian. A matrix is denoted to be unitary if it follows the spectral theorem which is listed below.
\begin{mdframed}
\textbf{Spectral Theorem:}
Let \( U \) be a normalized \( K \times K \) complex matrix. There exists an orthonormal basis of \( K \)-dimensional complex vectors \( \{|\psi_1\rangle, \dots, |\psi_K\rangle\} \), along with complex numbers \( \lambda_1, \dots, \lambda_K \), such that 
\( U = \lambda_1 |\psi_1\rangle \langle \psi_1| + \cdots + \lambda_K |\psi_K\rangle \langle \psi_K|.\)
This matrix \( U \) can be diagonalized in an orthonormal basis consisting of its eigenvectors, with the corresponding eigenvalues on the diagonal.
\end{mdframed}
\vspace{-0.3cm}
The main implementation of the phase estimation algorithm is shown below:
\begin{mdframed}
\textbf{Quantum Phase Estimation Algorithm:}
\begin{itemize}
\item \textbf{Input:}
An \( n \)-qubit quantum state \( |\psi\rangle \) and a unitary quantum circuit for an \( n \)-qubit operation \( U \).
\item \textbf{Promise/Assumptions:}
\( |\psi\rangle \) is an eigenvector of \( U \).
\item \textbf{Output:}
An approximation to the number \( \theta \in [0,1) \) satisfying 
\(U |\psi\rangle = e^{2\pi i \theta} |\psi\rangle.\)
\end{itemize}
\end{mdframed}
Quantum phase estimation can also take a probablistic approach in the form of Bayesian optimization. Termed Bayesian Quantum Phase Estimation by Weibe and Granade in 2016 \cite{Weibe2016}. It was made efficient in a highly noisy environment by Yamamoto et al. (2024) \cite{Yamamoto2023}. 
This method uses a quantum circuit to represent the posterior distribution of the phase estimation algorithm \cite{Weibe2016, Yamamoto2023}. For a two qubit circuit, the authors used a quantum circuit which is an acyclic network of quantum gates connected by wires. The quantum
gates are matrices that represent quantum operations while the wires represent the \textbf{qubits} (see appendix) on which the gates act. The pictoral representation of the circuit is shown in Figure 1 (below). 
\begin{wrapfigure}{r}{0.40\textwidth}
\includegraphics[width=0.40\textwidth]{tex/circuit.png}
\end{wrapfigure}
The quantum circuit is parameterized by \(k \in \mathbb{N}$ and \(\beta \in [0,1]\). The circuit is measured in the Pauli X basis and the measurement is denoted as a probability of states (or a likelihood) in the computational basis such that \(p(m\vert \phi, k, \beta) = \frac{1 + cos(k\phi + \beta)}{2}\)
where m is the measurement outcome in the computational basis, $\phi$ is the unknown where \(p(\phi)\sim \text{Unif}[0, 2\pi)\), and RZ is a rotational matrice described in the appendix below. 
With R possible measurement outcomes and high number of iterations, a posterior distribution can be computed such that $p(\phi \vert m, k, \beta) \propto p(\phi) \cdot \Pi^R_{r=1}p(m_r | \phi, k+r, \beta_r)$. Once converged, the probabilities distributions are then used to compute a posterior mean with respect to a observable or \(\Sigma_R p(\phi \vert m, k, \beta) \langle  R | \hat{H} | R \rangle \). 


### \underline{Problem Formulation}{-} 
\vspace{-0.3cm}
\begin{wrapfigure}{r}{0.40\textwidth}
\includegraphics[width=0.40\textwidth]{tex/potential_energy_graph.png}
\end{wrapfigure}
A common problem in current quantum computing algorithms is the number of  gates to be used in a circuit. A higher number of gates often results in State Preparation and Measurement (SPAM) Errors which can lead to inaccurate results. While the requirements of the Yamamoto et. al, 2024, scaled down to ensure 920 gates or less, this is still not enough to prevent errors in estimating molecular properties of molecules with elements beyond the first row of the periodic table. Thus, the goal of this project is to implement a Bayesian Optimization Method to roughly estimate the eigenvector of a Hamiltonian while also minimizing the number of gates used in the quantum algorithm for a discrete variable representation of the Hamiltonian which already minimizes the number of qubits used. The algorithm will be tested on a dichromium gas (Cr$_2$) model. 
\vspace{-0.7cm}

### \underline{Data Preprocessing and Generation of Unitary Matrices} {-} 
\vspace{-0.3cm}
The data used in this project was generated by Asnaashari and is a discrete variable representation of the Hamiltonian \cite{asnaashari2023compact}. First, an interpotential curve (measures the Coloumbic interaction of two atoms) was generated from Fortran for the Cr$_2$ molecule (Fig 2.). 

## \underline{Results} {-} 






\bibliographystyle{achemso}
\bibliography{tex/manuscript.bib}


## \underline{Appendix} {-} 
### \underline{A: Glossary of Some Quantum Computing Terms}  {-}
#### \underline{Bra} {-}
A row vector defined by: 

\begin{align}
   \langle  \psi \vert = \big [ \psi^\dagger_1, \psi^\dagger_2, ... , \psi^\dagger_K \big]
\end{align}

where $\psi^\dagger$ is the complex conjugate of $\psi$. 

#### \underline{Ket} {-}
A column vector defined by: 
\begin{align*}
    \vert \psi \rangle  = \big [ \psi_1, \psi_2, ... , \psi_K \big]^T
\end{align*}


#### \underline{Qubit} {-}
Represented by a complex-valued, \(2 \times 1\) vector. It can be written as a linear combination of \(\ket{0}\) and \(\ket{1}\) as follows:
\[
\ket{\psi} = \alpha\ket{0} + \beta\ket{1}
\] where \(\alpha\) and \(\beta\) are complex numbers, and \(|\alpha|^2 + |\beta|^2 = 1\). 
Note that \begin{align}
    \vert 0 \rangle  &=  [1 , 0]^T ,  \vert 1 \rangle = [0, 1]^T \end{align}

One does not observe $\alpha$ and $\beta$. Instead $|\alpha|^2$ and $|\beta|^2$  are the coefficients that we observe. Each of  $|\alpha|^2$ and $|\beta|^2$  and beta correspond to the probability of collapsing to a specific state. 


#### \underline{Computational Basis States} {-}
Refers to the standard orthonormal basis for the state space of \(n\) qubits and represents a complete set of orthonormal vectors for this space. For a single qubit, the computational basis consists of the two states \(\ket{0}\) and \(\ket{1}\). Each computational basis state for a system of \(n\) qubits can be described as a tensor product of \(n\) single-qubit states, where each qubit is independently in either \(\ket{0}\) or \(\ket{1}\). The computational basis states form an orthonormal basis, which implies that they are mutually orthogonal and each has unit norm. The completeness of this basis set means that any state \(\ket{\psi}\) of the system can be uniquely expressed as a linear combination of these basis states, and no other states need to be added to fully describe the state space. Each basis state corresponds to a unique binary string of length \(n\), which is particularly useful for encoding and manipulating information in quantum computation. The general form of a computational basis state for an \(n\)-qubit system is:
\[
\ket{i_1 i_2 \dots i_n} = \ket{i_1} \otimes \ket{i_2} \otimes \cdots \otimes \ket{i_n}
\]
where \(i_k\) is either 0 or 1, representing the state of the \(k\)-th qubit. For example, in a two-qubit system, the computational basis states are \(\ket{00}\), \(\ket{01}\), \(\ket{10}\), and \(\ket{11}\), corresponding to the vector representations \([1, 0, 0, 0]^T\), \([0, 1, 0, 0]^T\), \([0, 0, 1, 0]^T\), and \([0, 0, 0, 1]^T\) respectively. Note that \(\ket{00} = \ket{1}\) , \(\ket{01}= \ket{2}\), \(\ket{10}= \ket{3}\), and \(\ket{11}=\ket{4}\). This is because the number of computational basis states $(k)$ is proportional to the number of qubits $(N)$ s.t. 

\begin{align}
    k = 2^N  
\end{align}

### \underline{B: List of Quantum Gates Used in this Work} {-}
#### \underline{Pauli-Z Gate (\(Z\))} {-} 
  \[
  Z = \begin{bmatrix}
  1 & 0 \\
  0 & -1
  \end{bmatrix}
  \]


#### \underline{RZ Gate} {-} 

  \[
  R_{z,x_k}\left(\theta \right) = \begin{bmatrix}
  e^{-i\theta \cdot x_k} & 0 \\
  0 & e^{i\theta \cdot x_k} 
  \end{bmatrix}
  \]
